<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    /*Array객체

      1. 배열을 생성하는 방법
      let arr1 = []
      let arr2 = [1, 2, 3, 4]
      let arr3 = Array(); === let arr3 = []
      let arr4 = Array(number) -> 지정된 number갯수 크기를 갖는 빈 배열객체를 생성
      let arr5 = Array(any, ....., any) -> 매개변수를 요소의 값으로 갖는 배열객체를 생성
      
      배열의 요소도 속성이기 때문에 console.log(arr.0) -> 속성 이름이 유효하지 않기 때문에 
      구문 오류가 발생합니다.
      속성에 접근할 땐 꼭 대괄호 표기법을 사용해야된다. console.log(arr[0]) (o)
      다른 메서드(push(), splice()) 또한 배열의 length속성을 바꿀 수 있다.
      ex) let fruits = []
          fruits.push('바나나', '사과');
          console.log(fruits.length) // 길이 = 3
    */
  </script>
  <script>
    let arr1 = [4,2,1,7,5,9];

    // length : 배열의 크기
    document.write(`length = ${arr1.length}<br>`);

    // push() : 배열의 끝에 지정한 요소를 추가('문자열', 객체{}, function)도 추가 가능하다.
    // push함수는 두개의 배열을 합치는것도 가능하다. 
    // 합치기이해선 apply()를 사용해야되는데 만약 두번쨰 배열이 매우 클 경우, 이 메소드는 사용하지 말아야한다.
    document.write(`push = ${arr1.push(10, '손흥민', function() {})} => ${arr1}<br>`);

    // pop() : 배열끝의 요소를 꺼내오고 동시에 삭제
    // 배열에서 제거한 뒤 빈 배열의 경우 undefiend를 반환한다.
    document.write(`pop = ${arr1.pop()} => ${arr1}<br>`);

    // slice(start, end) : start ~ end(-1)까지 새로운배열 객체를 반환, 원본은 변경 안됨
    document.write(`slice = ${arr1.slice(0, 4)} => ${arr1}<br>`);

    // join('문자열') : 배열요소 전체를 지정한 문자열로 연결해서 하나의 문자열로 리턴한다(원본 변경 불가)
    document.write(`join = ${arr1.join('%')} => ${arr1}<br>`);

    // reverse() : 배열요소를 거꾸로 정렬한다(원본 변경 가능)
    document.write(`reverse = ${arr1.reverse()} => ${arr1}<br>`);

    // sort() : 배열요소를 정렬(원본 변경 가능) 
    document.write(`sort = ${arr1.sort()} => ${arr1}<br>`);

    /* map() : 원본배열을 가공해서 새로운 배열로 리턴(원본 변경 불가)
        map은 콜백함수를 각각의 요소에 대해 한번씩 순서대로 불러 그 함수의 반환값으로 새로운 배열을 만듭니다.
        콜백함수는 배열 값이 들어있는 인덱스에 대해서만 호출됩니다. 즉, 값이 삭제되거나 아직 값이 할당/정의
        되지 않은 인덱스에 대해서는 호출되지 않는다.
        map은 호출한 배열의 값을 변형하지 않는다. 단, 콜백함수에 의해서 변형될 수는 있다.
    */
    arr1 = [5, 22, 43, 11, 12]
    document.write(`map = ${arr1.map((a)=>{return a * 2;})} => ${arr1}<br>`);

    // filter() : 원본배열에서 특정 조건에 맞는 요소만 모아서 새로운 배열로 리턴(원본 변경 불가)
    document.write(`filter = ${arr1.filter(a => a > 16)} => ${arr1}<br>`);

    /* reduce : 요소들을 주어진 리듀서함수(reducer)를 실행한 후, 하나의 결과값을 반환
        리듀서함수는 네개의 인자를 가진다. 
        1. 누산기(acc): 반환 값이 할당, 2. 현재 값(cur) 3. 현재 인덱스 4. 원본 배열
        매개변수
        accumulator: 콜백의 이전 반환값 또는, 콜백의 첫 번쨰 호출, 초기값을 제공한 경우에는 초기값의 값입니다.
        cuurentValue: 처리할 현재 요소
        currentIndex: 처리할 현재 요소의 인덱스. 초기값을 제공한 경우 0, 아니면 1부터 시작
        array: reduce()를 호출한 배열
        initialValue: callback의 최초 호출에서 첫 번째 인수에 제공하는 값. 초기값을 제공하지 않으면 배열의 첫 번째 요소를 사용한다.
        빈 배열에서 초기값 없이 reduce()를 호출하면 오류가 발생한다.
        콜백의 최초 호출 때 이전값과 현재값은 다음 두 가지 값 중 하나를 가질수 있다.
        만약 reduce() 함수 호출에서 초기값을 제공한 경우, 이전값은 초기값과 같고 
        현재값은 배열의 첫 번째 값과 같습니다. 
        초기값을 제공하지 않았다면, 이전값은 배열의 첫 번째 값과 같고 현재값은 배열의 두번쨰값과 같습니다.
        초기값을 제공하지 않으면 출력 가능한 형식이 세 가지 존재하므로, 보통 초기값을 주는 것이 더 안전합니다.
     */
    const 초기값 = 0;
    const total = arr1.reduce((이전값, 현재값) => 이전값 + 현재값, 초기값);
    document.write(`reduce = ${total}<br>`);

    // forEach : 요소 각각에 주어진 함수를 실행
    // map(), reduce()와는 달리 undefiend를 반환하기 때문에 
    // 메서드 체인의 중간에 사용할 수 없다. 대표적인 사용처는 메서드 체인 끝에서 부작용을 실행함.
    arr1.forEach(a => console.log('forEach', a));
    arr1.forEach(a => {
      if(a > 15) {
        console.log('forEach', a);
      }
    });
    // concat : 배열을 합치는 함수
    let arr2 = ['asd', 'ffeee'];
    document.write(`${arr1.concat(arr2)}<br>`);

    // sort : 객체의 정렬
    function Student(name, kor, mat, his, eng) {
      this.name = name;
      this.kor = kor;
      this.mat = mat;
      this.his = his;
      this.eng = eng;

      this.getSum = () => this.kor + this.mat + this.his + this.eng;
      this.getAvg = () => this.getSum / 4;
      this.toString = () => `이름=${this.name},국어=${this.kor},수학=${this.mat},역사=${this.his},영어=${this.eng}`; 
    }

    let students = [];
    students.push(new Student('손흥민', 50, 45, 49, 88));
    students.push(new Student('이강인', 70, 65, 29, 68));
    students.push(new Student('김민재', 90, 45, 89, 38));

    // 총점순
    students.sort((a, b)=>{
      return b.getSum() - a.getSum();
    })
    for(let i in students) {
      document.write('sort(총점순) = ', students[i].toString(), '<br>');
    }
    document.write('<hr>');
    // 평균순
    students.sort((a, b)=>{
      return b.getAvg() - a.getAvg();
    })
    for(let i in students) {
      document.write('sort(평균순) = ', students[i].toString(), '<br>');
    }
    document.write('<hr>');
    // 2등까지만 출력
    let std = students.sort((a, b)=>{
      return b.getSum() - a.getSum();
    }).slice(0, 2);

    for(let i in std) {
      document.write('sort(2등까지만) = ', std[i].toString(), '<br>');
    }
  </script>
</head>
<body>
  
</body>
</html>